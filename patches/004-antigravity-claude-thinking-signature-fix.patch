From: CLI Proxy Custom Patches
Subject: [PATCH 004] Fix thinking signature handling for all models via Antigravity Gemini translator

When models are accessed through the Gemini v1beta endpoint and routed to
Antigravity, thinking blocks from previous conversation turns may carry
stale or cross-provider signatures that cause validation failures.

For Gemini models, the existing skip_thought_signature_validator sentinel
bypasses Google's signature validation. For Claude models, the sentinel is
NOT recognized by Claude's API, so thinking blocks must be stripped entirely
from previous assistant messages instead.

This also cleans up both camelCase (thoughtSignature) and snake_case
(thought_signature) signature fields, since clients like @ai-sdk/google
may send either format.

Key changes:
- For non-Claude models: apply skip sentinel to thinking and functionCall
  parts, also clear snake_case thought_signature to prevent passthrough
- For Claude models: strip thinking blocks from previous assistant turns
  and clear stale signatures from functionCall parts

---
diff --git a/internal/translator/antigravity/gemini/antigravity_gemini_request.go b/internal/translator/antigravity/gemini/antigravity_gemini_request.go
--- a/internal/translator/antigravity/gemini/antigravity_gemini_request.go
+++ b/internal/translator/antigravity/gemini/antigravity_gemini_request.go
@@ -154,35 +154,51 @@
 		return true
 	})
 
-	// Gemini-specific handling for non-Claude models:
-	// - Add skip_thought_signature_validator to functionCall parts so upstream can bypass signature validation.
-	// - Also mark thinking parts with the same sentinel when present (we keep the parts; we only annotate them).
-	if !strings.Contains(modelName, "claude") {
+	// Handle thinking signatures for all models routed through Antigravity.
+	// For Gemini models: add skip_thought_signature_validator sentinel (Google honors it).
+	// For Claude models: strip thinking blocks entirely from previous assistant turns,
+	// because Claude rejects the sentinel as an invalid signature.
+	// Also clean up snake_case thought_signature to prevent stale cross-provider
+	// signatures from passing through to the upstream API.
+	isClaude := strings.Contains(modelName, "claude")
+	{
 		const skipSentinel = "skip_thought_signature_validator"
 
 		gjson.GetBytes(rawJSON, "request.contents").ForEach(func(contentIdx, content gjson.Result) bool {
 			if content.Get("role").String() == "model" {
-				// First pass: collect indices of thinking parts to mark with skip sentinel
-				var thinkingIndicesToSkipSignature []int64
+				var thinkingIndicesToProcess []int64
 				content.Get("parts").ForEach(func(partIdx, part gjson.Result) bool {
-					// Collect indices of thinking blocks to mark with skip sentinel
 					if part.Get("thought").Bool() {
-						thinkingIndicesToSkipSignature = append(thinkingIndicesToSkipSignature, partIdx.Int())
+						thinkingIndicesToProcess = append(thinkingIndicesToProcess, partIdx.Int())
 					}
-					// Add skip sentinel to functionCall parts
 					if part.Get("functionCall").Exists() {
-						existingSig := part.Get("thoughtSignature").String()
-						if existingSig == "" || len(existingSig) < 50 {
-							rawJSON, _ = sjson.SetBytes(rawJSON, fmt.Sprintf("request.contents.%d.parts.%d.thoughtSignature", contentIdx.Int(), partIdx.Int()), skipSentinel)
+						basePath := fmt.Sprintf("request.contents.%d.parts.%d", contentIdx.Int(), partIdx.Int())
+						if isClaude {
+							// Clear stale signatures from functionCall parts for Claude
+							rawJSON, _ = sjson.DeleteBytes(rawJSON, basePath+".thoughtSignature")
+							rawJSON, _ = sjson.DeleteBytes(rawJSON, basePath+".thought_signature")
+						} else {
+							existingSig := part.Get("thoughtSignature").String()
+							if existingSig == "" || len(existingSig) < 50 {
+								rawJSON, _ = sjson.SetBytes(rawJSON, basePath+".thoughtSignature", skipSentinel)
+							}
+							rawJSON, _ = sjson.DeleteBytes(rawJSON, basePath+".thought_signature")
 						}
 					}
 					return true
 				})
 
-				// Add skip_thought_signature_validator sentinel to thinking blocks in reverse order to preserve indices
-				for i := len(thinkingIndicesToSkipSignature) - 1; i >= 0; i-- {
-					idx := thinkingIndicesToSkipSignature[i]
-					rawJSON, _ = sjson.SetBytes(rawJSON, fmt.Sprintf("request.contents.%d.parts.%d.thoughtSignature", contentIdx.Int(), idx), skipSentinel)
+				// Process thinking blocks in reverse order to preserve indices
+				for i := len(thinkingIndicesToProcess) - 1; i >= 0; i-- {
+					idx := thinkingIndicesToProcess[i]
+					basePath := fmt.Sprintf("request.contents.%d.parts.%d", contentIdx.Int(), idx)
+					if isClaude {
+						// Strip thinking blocks for Claude - the sentinel is not a valid Claude signature
+						rawJSON, _ = sjson.DeleteBytes(rawJSON, basePath)
+					} else {
+						rawJSON, _ = sjson.SetBytes(rawJSON, basePath+".thoughtSignature", skipSentinel)
+						rawJSON, _ = sjson.DeleteBytes(rawJSON, basePath+".thought_signature")
+					}
 				}
 			}
 			return true
