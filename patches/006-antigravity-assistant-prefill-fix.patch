# PATCH 006: Handle assistant message prefill for Claude models via Antigravity
#
# When clients (e.g. opencode, Claude Code) send a Claude API request with
# assistant prefill (last message has role "assistant" with partial content),
# the Antigravity/Gemini backend rejects it.
#
# This patch handles it in both Claude-to-Antigravity and Gemini-to-Antigravity
# translators (scoped to Claude models only) by:
# 1. Detecting trailing "model" messages without functionCall parts
# 2. Extracting text content as prefill
# 3. Removing the trailing model message
# 4. Appending a synthetic user message with continuation hint
#
# Native Gemini models are unaffected.
diff --git a/internal/translator/antigravity/claude/antigravity_claude_request.go b/internal/translator/antigravity/claude/antigravity_claude_request.go
--- a/internal/translator/antigravity/claude/antigravity_claude_request.go
+++ b/internal/translator/antigravity/claude/antigravity_claude_request.go
@@ -308,6 +308,61 @@
 		}
 	}
 
+	// Handle assistant prefill: if the last message has role "model", the Antigravity
+	// API will reject the request ("This model does not support assistant message prefill.
+	// The conversation must end with a user message."). Extract the prefill text and
+	// replace it with a synthetic user message that preserves the intent.
+	if hasContents {
+		contentsArray := gjson.Parse(contentsJSON).Array()
+		if len(contentsArray) > 0 {
+			lastContent := contentsArray[len(contentsArray)-1]
+			if lastContent.Get("role").String() == "model" {
+				// Check that the last model message has no functionCall parts
+				// (those are legitimate mid-conversation tool-use turns, not prefill)
+				hasFunctionCall := false
+				lastContent.Get("parts").ForEach(func(_, part gjson.Result) bool {
+					if part.Get("functionCall").Exists() {
+						hasFunctionCall = true
+						return false
+					}
+					return true
+				})
+
+				if !hasFunctionCall {
+					// Collect text parts from the trailing model message
+					var prefillTexts []string
+					lastContent.Get("parts").ForEach(func(_, part gjson.Result) bool {
+						if t := part.Get("text").String(); t != "" {
+							prefillTexts = append(prefillTexts, t)
+						}
+						return true
+					})
+
+					// Remove the trailing model message
+					trimmedContents := "[]"
+					for idx := 0; idx < len(contentsArray)-1; idx++ {
+						trimmedContents, _ = sjson.SetRaw(trimmedContents, "-1", contentsArray[idx].Raw)
+					}
+					contentsJSON = trimmedContents
+
+					// If the prefill had text content, inject a synthetic user message
+					// so the model receives the intended continuation hint
+					if len(prefillTexts) > 0 {
+						prefill := strings.Join(prefillTexts, "")
+						syntheticUser := `{"role":"user","parts":[]}`
+						partJSON := `{}`
+						partJSON, _ = sjson.Set(partJSON, "text", "Continue from: "+prefill)
+						syntheticUser, _ = sjson.SetRaw(syntheticUser, "parts.-1", partJSON)
+						contentsJSON, _ = sjson.SetRaw(contentsJSON, "-1", syntheticUser)
+					}
+
+					// Update hasContents based on remaining contents
+					hasContents = len(gjson.Parse(contentsJSON).Array()) > 0
+				}
+			}
+		}
+	}
+
 	// tools
 	toolsJSON := ""
 	toolDeclCount := 0
diff --git a/internal/translator/antigravity/gemini/antigravity_gemini_request.go b/internal/translator/antigravity/gemini/antigravity_gemini_request.go
--- a/internal/translator/antigravity/gemini/antigravity_gemini_request.go
+++ b/internal/translator/antigravity/gemini/antigravity_gemini_request.go
@@ -87,6 +87,56 @@
 		})
 	}
 
+	// Handle assistant prefill for Claude models routed via the Gemini translator:
+	// if the last content has role "model", the Antigravity API will reject the request.
+	// Only applies to Claude models â€” native Gemini models do not receive prefill.
+	if strings.Contains(modelName, "claude") {
+		contents = gjson.GetBytes(rawJSON, "request.contents")
+		if contents.Exists() && contents.IsArray() {
+			contentsArray := contents.Array()
+			if len(contentsArray) > 0 {
+				lastContent := contentsArray[len(contentsArray)-1]
+				if lastContent.Get("role").String() == "model" {
+					// Check that the last model message has no functionCall parts
+					// (those are legitimate mid-conversation tool-use turns, not prefill)
+					hasFunctionCall := false
+					lastContent.Get("parts").ForEach(func(_, part gjson.Result) bool {
+						if part.Get("functionCall").Exists() {
+							hasFunctionCall = true
+							return false
+						}
+						return true
+					})
+
+					if !hasFunctionCall {
+						// Collect text parts from the trailing model message
+						var prefillTexts []string
+						lastContent.Get("parts").ForEach(func(_, part gjson.Result) bool {
+							if t := part.Get("text").String(); t != "" {
+								prefillTexts = append(prefillTexts, t)
+							}
+							return true
+						})
+
+						// Remove the trailing model message
+						lastIdx := len(contentsArray) - 1
+						rawJSON, _ = sjson.DeleteBytes(rawJSON, fmt.Sprintf("request.contents.%d", lastIdx))
+
+						// If the prefill had text content, inject a synthetic user message
+						if len(prefillTexts) > 0 {
+							prefill := strings.Join(prefillTexts, "")
+							syntheticUser := `{"role":"user","parts":[]}`
+							partJSON := `{}`
+							partJSON, _ = sjson.Set(partJSON, "text", "Continue from: "+prefill)
+							syntheticUser, _ = sjson.SetRaw(syntheticUser, "parts.-1", partJSON)
+							rawJSON, _ = sjson.SetRawBytes(rawJSON, "request.contents.-1", []byte(syntheticUser))
+						}
+					}
+				}
+			}
+		}
+	}
+
 	toolsResult := gjson.GetBytes(rawJSON, "request.tools")
 	if toolsResult.Exists() && toolsResult.IsArray() {
 		toolResults := toolsResult.Array()
