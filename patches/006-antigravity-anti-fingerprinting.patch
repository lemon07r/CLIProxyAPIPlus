# PATCH 006: Antigravity anti-fingerprinting
#
# Fixes three fingerprinting vectors in the Antigravity executor:
#
# 1. Session ID: Salt with auth ID to prevent cross-account correlation,
#    fix format to match real traffic (-{uuid}:{model}:{project}:seed-{hex16})
#
# 2. User-Agent: Fix version format (use Antigravity's own version, not VS Code's),
#    generate per-account UA with varied version/platform, cache for consistency
#
# 3. Project ID: Expand word pools from 5x5 (25 combos) to 30x30 (900 combos)
#
--- a/internal/runtime/executor/antigravity_executor.go	2026-02-20 22:24:33.687612958 +0000
+++ b/internal/runtime/executor/antigravity_executor.go	2026-02-20 22:26:03.463968874 +0000
@@ -9,6 +9,7 @@
 	"context"
 	"crypto/sha256"
 	"encoding/binary"
+	"encoding/hex"
 	"encoding/json"
 	"errors"
 	"fmt"
@@ -45,7 +46,7 @@
 	antigravityModelsPath          = "/v1internal:fetchAvailableModels"
 	antigravityClientID            = "1071006060591-tmhssin2h21lcre235vtolojh4g403ep.apps.googleusercontent.com"
 	antigravityClientSecret        = "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"
-	defaultAntigravityAgent        = "antigravity/1.104.0 darwin/arm64"
+	defaultAntigravityAgent        = "antigravity/1.18.3 darwin/arm64"
 	antigravityAuthType            = "antigravity"
 	refreshSkew                    = 3000 * time.Second
 	systemInstruction              = "You are Antigravity, a powerful agentic AI coding assistant designed by the Google Deepmind team working on Advanced Agentic Coding.You are pair programming with a USER to solve their coding task. The task may require creating a new codebase, modifying or debugging an existing codebase, or simply answering a question.**Absolute paths only****Proactiveness**"
@@ -54,6 +55,12 @@
 var (
 	randSource      = rand.New(rand.NewSource(time.Now().UnixNano()))
 	randSourceMutex sync.Mutex
+
+	antigravityUACache      = make(map[string]string)
+	antigravityUACacheMutex sync.RWMutex
+
+	antigravityUAVersions  = []string{"1.16.5", "1.17.0", "1.17.2", "1.18.0", "1.18.3"}
+	antigravityUAPlatforms = []string{"win32/x64", "darwin/arm64", "linux/x64", "linux/arm64"}
 )
 
 // AntigravityExecutor proxies requests to the antigravity upstream.
@@ -1290,7 +1297,11 @@
 			projectID = strings.TrimSpace(pid)
 		}
 	}
-	payload = geminiToAntigravity(modelName, payload, projectID)
+	var authID string
+	if auth != nil {
+		authID = auth.ID
+	}
+	payload = geminiToAntigravity(modelName, payload, projectID, authID)
 	payload, _ = sjson.SetBytes(payload, "model", modelName)
 
 	useAntigravitySchema := strings.Contains(modelName, "claude") || strings.Contains(modelName, "gemini-3-pro-high")
@@ -1342,9 +1353,8 @@
 		httpReq.Host = host
 	}
 
-	var authID, authLabel, authType, authValue string
+	var authLabel, authType, authValue string
 	if auth != nil {
-		authID = auth.ID
 		authLabel = auth.Label
 		authType, authValue = auth.AccountInfo()
 	}
@@ -1455,6 +1465,22 @@
 				return strings.TrimSpace(ua)
 			}
 		}
+		if auth.ID != "" {
+			antigravityUACacheMutex.RLock()
+			ua, ok := antigravityUACache[auth.ID]
+			antigravityUACacheMutex.RUnlock()
+			if ok {
+				return ua
+			}
+			h := sha256.Sum256([]byte(auth.ID + "ua-salt"))
+			vIdx := int(binary.BigEndian.Uint32(h[:4])) % len(antigravityUAVersions)
+			pIdx := int(binary.BigEndian.Uint32(h[4:8])) % len(antigravityUAPlatforms)
+			ua = fmt.Sprintf("antigravity/%s %s", antigravityUAVersions[vIdx], antigravityUAPlatforms[pIdx])
+			antigravityUACacheMutex.Lock()
+			antigravityUACache[auth.ID] = ua
+			antigravityUACacheMutex.Unlock()
+			return ua
+		}
 	}
 	return defaultAntigravityAgent
 }
@@ -1546,7 +1572,7 @@
 	return ""
 }
 
-func geminiToAntigravity(modelName string, payload []byte, projectID string) []byte {
+func geminiToAntigravity(modelName string, payload []byte, projectID string, authID string) []byte {
 	template, _ := sjson.Set(string(payload), "model", modelName)
 	template, _ = sjson.Set(template, "userAgent", "antigravity")
 	template, _ = sjson.Set(template, "requestType", "agent")
@@ -1555,10 +1581,11 @@
 	if projectID != "" {
 		template, _ = sjson.Set(template, "project", projectID)
 	} else {
-		template, _ = sjson.Set(template, "project", generateProjectID())
+		projectID = generateProjectID()
+		template, _ = sjson.Set(template, "project", projectID)
 	}
 	template, _ = sjson.Set(template, "requestId", generateRequestID())
-	template, _ = sjson.Set(template, "request.sessionId", generateStableSessionID(payload))
+	template, _ = sjson.Set(template, "request.sessionId", generateStableSessionID(payload, authID, modelName, projectID))
 
 	template, _ = sjson.Delete(template, "request.safetySettings")
 	if toolConfig := gjson.Get(template, "toolConfig"); toolConfig.Exists() && !gjson.Get(template, "request.toolConfig").Exists() {
@@ -1579,26 +1606,59 @@
 	return "-" + strconv.FormatInt(n, 10)
 }
 
-func generateStableSessionID(payload []byte) string {
+func generateStableSessionID(payload []byte, authID, modelName, projectID string) string {
+	firstUserText := ""
 	contents := gjson.GetBytes(payload, "request.contents")
 	if contents.IsArray() {
 		for _, content := range contents.Array() {
 			if content.Get("role").String() == "user" {
 				text := content.Get("parts.0.text").String()
 				if text != "" {
-					h := sha256.Sum256([]byte(text))
-					n := int64(binary.BigEndian.Uint64(h[:8])) & 0x7FFFFFFFFFFFFFFF
-					return "-" + strconv.FormatInt(n, 10)
+					firstUserText = text
+					break
 				}
 			}
 		}
 	}
-	return generateSessionID()
+
+	// Generate stable UUID from auth ID + first user text
+	h := sha256.Sum256([]byte(authID + ":" + firstUserText))
+	uuidBytes := make([]byte, 16)
+	copy(uuidBytes, h[:16])
+	// Set UUID v4 variant bits
+	uuidBytes[6] = (uuidBytes[6] & 0x0f) | 0x40
+	uuidBytes[8] = (uuidBytes[8] & 0x3f) | 0x80
+	stableUUID := fmt.Sprintf("%x-%x-%x-%x-%x", uuidBytes[0:4], uuidBytes[4:6], uuidBytes[6:8], uuidBytes[8:10], uuidBytes[10:16])
+
+	// Generate random seed hex
+	randSourceMutex.Lock()
+	seedBytes := make([]byte, 8)
+	for i := range seedBytes {
+		seedBytes[i] = byte(randSource.Intn(256))
+	}
+	randSourceMutex.Unlock()
+	seedHex := hex.EncodeToString(seedBytes)
+
+	return fmt.Sprintf("-%s:%s:%s:seed-%s", stableUUID, modelName, projectID, seedHex)
 }
 
 func generateProjectID() string {
-	adjectives := []string{"useful", "bright", "swift", "calm", "bold"}
-	nouns := []string{"fuze", "wave", "spark", "flow", "core"}
+	adjectives := []string{
+		"zippy", "ethereal", "shaped", "symbolic", "coral",
+		"refined", "bright", "swift", "calm", "bold",
+		"vivid", "gentle", "lucid", "crisp", "deft",
+		"keen", "plush", "sleek", "tidy", "warm",
+		"agile", "brisk", "clever", "daring", "eager",
+		"fancy", "golden", "humble", "jolly", "lively",
+	}
+	nouns := []string{
+		"memento", "sunup", "reef", "zucchini", "cubist",
+		"zepplin", "fuze", "wave", "spark", "flow",
+		"prism", "grove", "delta", "ridge", "bloom",
+		"crest", "haven", "nexus", "orbit", "pulse",
+		"quartz", "shard", "thorn", "vault", "whirl",
+		"atlas", "blaze", "cedar", "drift", "ember",
+	}
 	randSourceMutex.Lock()
 	adj := adjectives[randSource.Intn(len(adjectives))]
 	noun := nouns[randSource.Intn(len(nouns))]
