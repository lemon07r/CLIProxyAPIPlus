From: CLI Proxy Custom Patches
Subject: [PATCH 003] Tool ID Fix for Antigravity Claude Models

This patch injects missing tool IDs for functionCall and functionResponse
in Gemini requests. This is required for Antigravity Claude models which
validate tool_use.id fields.

Key changes:
- Add crypto/rand and encoding/hex imports
- Add generateToolID() function to create unique tool IDs
- Add tool ID injection logic for functionCall and functionResponse

---
diff --git a/internal/translator/gemini/gemini/gemini_gemini_request.go b/internal/translator/gemini/gemini/gemini_gemini_request.go
--- a/internal/translator/gemini/gemini/gemini_gemini_request.go
+++ b/internal/translator/gemini/gemini/gemini_gemini_request.go
@@ -4,6 +4,8 @@
 package gemini
 
 import (
+	"crypto/rand"
+	"encoding/hex"
 	"fmt"
 
 	"github.com/router-for-me/CLIProxyAPI/v6/internal/translator/gemini/common"
@@ -12,6 +14,14 @@ import (
 	"github.com/tidwall/sjson"
 )
 
+// generateToolID generates a unique tool ID for function calls.
+// This is required for Antigravity Claude models which validate tool_use.id.
+func generateToolID() string {
+	b := make([]byte, 12)
+	rand.Read(b)
+	return "toolu_" + hex.EncodeToString(b)
+}
+
 // ConvertGeminiRequestToGemini normalizes Gemini v1beta requests.
 //   - Adds a default role for each content if missing or invalid.
 //     The first message defaults to "user", then alternates user/model when needed.
@@ -95,6 +105,34 @@ func ConvertGeminiRequestToGemini(_ string, inputRawJSON []byte, _ bool) []byte
 		out = []byte(strJson)
 	}
 
+	// Inject missing tool IDs for functionCall and functionResponse
+	// This is required for Antigravity Claude models which validate tool_use.id
+	toolIDMap := make(map[string]string)
+	gjson.GetBytes(out, "contents").ForEach(func(contentKey, contentVal gjson.Result) bool {
+		contentVal.Get("parts").ForEach(func(partKey, partVal gjson.Result) bool {
+			// Handle functionCall - generate ID if missing
+			if partVal.Get("functionCall").Exists() {
+				if !partVal.Get("functionCall.id").Exists() || partVal.Get("functionCall.id").String() == "" {
+					toolID := generateToolID()
+					funcName := partVal.Get("functionCall.name").String()
+					toolIDMap[funcName] = toolID
+					out, _ = sjson.SetBytes(out, fmt.Sprintf("contents.%d.parts.%d.functionCall.id", contentKey.Int(), partKey.Int()), toolID)
+				}
+			}
+			// Handle functionResponse - match ID from corresponding functionCall
+			if partVal.Get("functionResponse").Exists() {
+				if !partVal.Get("functionResponse.id").Exists() || partVal.Get("functionResponse.id").String() == "" {
+					funcName := partVal.Get("functionResponse.name").String()
+					if id, ok := toolIDMap[funcName]; ok {
+						out, _ = sjson.SetBytes(out, fmt.Sprintf("contents.%d.parts.%d.functionResponse.id", contentKey.Int(), partKey.Int()), id)
+					}
+				}
+			}
+			return true
+		})
+		return true
+	})
+
 	out = common.AttachDefaultSafetySettings(out, "safetySettings")
 	return out
 }
